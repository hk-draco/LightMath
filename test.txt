
infixl 10 ^
infixl 9  *
infixl 9  /
infixl 8  %
infixl 8  +
infixl 8  -
infixl 7  =
infixl 7  <
infixl 7  >
infixl 7  <=
infixl 7  >=
unaryr 6  ~
infixl 5  &
infixl 4  |
infixl 3  =
infixl 2  =>
infixl 2  ->
infixl 1  <=>

data N = Zero | Succ(N)
undef R: Type

undef f: N->N
undef g: (N, N)->N

undef operator +	: (N, N)->N 			latex "+" 
undef operator *	: (N, N)->N 			latex "\cdot"
# undef operator =>	: (Prop, Prop)->Prop 	latex "\rightarrow"
undef operator &	: (Prop, Prop)->Prop 	latex "\land"
undef operator |	: (Prop, Prop)->Prop 	latex "\lir"
undef operator ~	: Prop->Prop 			latex "\lnot"
undef inv			: R->R 					latex "$^{-1}"
undef mns			: R->R 					latex "-"

axiom (a, b: N) 	{ a + b = b + a }
axiom (a, b, c: N) 	{ a + (b + c) = (a + b) + c }
axiom (a, b: N) 	{ a * b = b * a }
axiom (a, b, c: N) 	{ a * (b * c) = (a * b) * c }

axiom (a: N) { a + 0 >>= a }
axiom (a: N) { a * 0 >>= 0 }
axiom (a: N) { a * 1 >>= a }
axiom (A: Prop, B: Prop) { A & B => A }

undef True	: Prop
undef False	: Prop

axiom { ~False >>= True  }
axiom { ~True  >>= False }

axiom (A, B: Prop) 		{ A & B <=> B & A }
axiom (A, B, C: Prop) 	{ A & (B & C) <=> (A & B) & C }
axiom (A, B: Prop) 		{ A | B <=> B | A }
axiom (A, B, C: Prop) 	{ A | (B | C) <=> (A | B) | C }
axiom (A: Prop) { ~(~A) >>= A }
axiom (A: Prop) { A & True >>= A }
axiom (A: Prop) { A | True >>= True }
axiom (A: Prop) { A & A >>= A }
axiom (A: Prop) { A | A >>= A }

def operator => (A, B: Prop): Prop { A | ~B }

axiom (A: Prop) {
	A | A >>= A
}

theorem (A, B: Prop) {
	(A => B) => (A | ~B)
proof:
	step A => B
	unfold A | ~B
}

theorem (A, B, P, Q: Prop) {
	((A => P) & (B => Q)) => ((A & B) => (P & Q))
proof:
	step (A => P) & (B => Q)
	step (~A | P) & (~B | Q)
	step ~A & ~B | ~A & Q | P & ~B | P & Q
	impl ~A & ~B | ~A | P & ~B | P & Q
	impl ~A & ~B | ~A | ~B | P & Q
	step ~(A | B) | ~(A & B) | (P & Q)
	step ((A | B) & (A & B)) => P & Q
	step (A & B & A | B & A & B) => P & Q
	step (A & B | A & B) => P & Q
	step (A & B) => (P & Q)
}