
infixl 10 ^
infixl 9  *
infixl 9  /
infixl 8  %
infixl 8  +
infixl 8  -
infixl 7  =
infixl 7  <
infixl 7  >
infixl 7  <=
infixl 7  >=
unaryr 6  ~
infixl 5  &
infixl 4  |
infixl 3  =
infixl 2  =>
infixl 2  ->
infixl 1  <=>

data N = Zero | Succ(N)
undef R: Type

undef operator <	: (R, R)->Prop
undef operator >	: (R, R)->Prop
undef operator <=	: (R, R)->Prop
undef operator >=	: (R, R)->Prop

undef operator +	: (R, R)->R 			latex "+" 
undef operator *	: (R, R)->R 			latex "\cdot"
# undef operator =>	: (Prop, Prop)->Prop 	latex "\rightarrow"
undef operator &	: (Prop, Prop)->Prop 	latex "\land"
undef operator |	: (Prop, Prop)->Prop 	latex "\lir"
undef operator ~	: Prop->Prop 			latex "\lnot"
undef inv			: R->R 					latex "$^{-1}"
undef mns			: R->R 					latex "-"

axiom (a, b: R) 	{ a + b = b + a }
axiom (a, b, c: R) 	{ a + (b + c) = (a + b) + c }
axiom (a, b: R) 	{ a * b = b * a }
axiom (a, b, c: R) 	{ a * (b * c) = (a * b) * c }

axiom (a: R) { a + 0 >>= a }
axiom (a: R) { a * 0 >>= 0 }
axiom (a: R) { a * 1 >>= a }

undef True	: Prop
undef False	: Prop

axiom { ~False >>= True  }
axiom { ~True  >>= False }

axiom (A, B: Prop) 		{ A & B <=> B & A }
axiom (A, B, C: Prop) 	{ A & (B & C) <=> (A & B) & C }
axiom (A, B: Prop) 		{ A | B <=> B | A }
axiom (A, B, C: Prop) 	{ A | (B | C) <=> (A | B) | C }

axiom (A: Prop) { ~(~A) >>= A }

axiom (A: Prop) { A | True >>= True }
axiom (A: Prop) { A | False >>= A }
axiom (A: Prop) { A | A >>= A }

axiom (A: Prop) { A & True >>= A }
axiom (A: Prop) { A & False >>= False }
axiom (A: Prop) { A & A >>= A }

axiom (A, B: Prop) { ~(A & B) >>= ~A | ~B }
axiom (A, B: Prop) { ~(A | B) >>= ~A & ~B }

axiom (A, B: Prop) { A & B => B }

axiom (a, b, c: R)    { (a + b) * c >>= a * c + b * c }
axiom (A, B, C: Prop) { (A | B) & C >>= A & C | B & C }

axiom (A: Prop) { A | A >>= A }

axiom (A: Prop) { A & ~A >>= False }
axiom (A: Prop) { A | ~A >>= True }

axiom (a: R) 		{ a <= a >>= True }
axiom (a, b: R) 	{ a <= b & b <= a >>= a = b }
axiom (a, b, c: R) 	{ a <= b & b <= c => a <= c }
axiom (a, b: R) 	{ a <= b | b <= a >>= True }
axiom (a, b, c: R) 	{ a + c <= b + c  >>= a <= b  }
axiom (a, b: R) 	{ a >= 0 & b >= 0 => a * b >= 0 }

axiom (A, B, C: Prop) {
	(A | B) & C >>= A & C | B & C
}

def operator => (A, B: Prop): Prop { ~A | B }

theorem (A, B: Prop) {
	(A => B) => (~A | B)
proof:
	step A => B
	unfold ~A | B
}

pred Max[x: A] (A: R) {
	a <= x+t
}

theorem (A, B, P, Q: Prop) {
	((A => P) & (B => Q)) => ((A & B) => (P & Q))
proof:
	unfold (~A | P) & (~B | Q)
	step ~A & ~B | ~A & Q | P & ~B | P & Q
	impl ~A & ~B | ~A | ~B | P & Q
	step ~((A | B) & (A & B)) | (P & Q)
	impl ~(A & B) | (P & Q)
	fold (A & B) => (P & Q)
}
